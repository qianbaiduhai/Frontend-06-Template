学习笔记

字符串分析算法:
-  字典树
-  KMP
-  Wildcard
-  正则
-  状态机
-  LL LR

**字典树**
> 又名单词查找书，Trie树，树结构，是哈希树的变种。

特性：
1、根节点不包含字符，除根节点外的每一个子节点都包含一个字符
2、从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串
3、每个单词的公共前缀作为一个字符节点保存

应用领域：
1、词频统计
2、前缀匹配
3、文本搜索
4、排序

优点：
1、查询速度快 O(log L) ,L是字符串长度
2、比哈希更少的空间


**KMP**
> 字符串查询算法，常用于在一串文本串S内查找一个模式串P的出现位置。

其核心在于计算部分匹配表(Partial Match Table)的数组

PMT主要存储的是target串的部分匹配系数，PMT系数帮助我们快速定位J，避免i回指，同时减小J回指的长度

![部分匹配表demo](https://img-blog.csdn.net/20180415181821494?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hfXzE5OTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度，
PMT系数帮助我们快速定位J，避免i回指，同时减小J回指的长度

优化：
- BM算法：KMP的匹配是从模式串的开头开始匹配的，而BM算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度
> 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1
> 好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1

- Sunday算法：思路与BM类似，不同之处，从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符
> 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1
> 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1


**Wildcard**
>  通配符算法，暂无更多资料。。。

---
参考文章

[6天通吃树结构—— 第五天 Trie树](https://www.cnblogs.com/huangxincheng/archive/2012/11/25/2788268.html)
[KMP算法详解](https://blog.csdn.net/qq_28619473/article/details/88760101)
[KMP算法的优化与详解](https://www.cnblogs.com/cherryljr/p/6519748.html)
